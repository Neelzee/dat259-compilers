# Syntax Translation

Once, a grammar has become stable, it is time to move on and start building the rest of your compiler chain, i.e.
semantic analyzers, translators etc.
There are two principal ways to achieve this: 
Either by _semantic actions_ that are written directly into the grammar, or building on the _listener_- respectively _visitor_-based implementations
that are generated by Antlr. 
The second approach should be preferred since it keeps the grammar implementation-language-agnostic.


## Generating Antlr code

Per default, when invoking `antlr` with any further arguments on your grammar file, Antlr generates a lexer, a parser, and a parse-tree listener for your language in Java (including some auxiliary files such as a list of all tokens).

You may adjust this behviour with following options
```bash
antlr \
 -o DIR \ # change the output directory og generated files 
 -package NAME \ # change the package/namespace of generated files (in language that have such featres)
 -no-listener \ #
 -visitor \ # deactive listener and use visitor instead
 -Dlanguage=LANG \ # generate for a language different from java
 GRAMMAR.g4
```

The available language targets are listed on the Antlr web page:

- Java (default)
- [C#](https://github.com/antlr/antlr4/blob/master/doc/csharp-target.md)
- [Python](https://github.com/antlr/antlr4/blob/master/doc/python-target.md)
- [JavaScript](https://github.com/antlr/antlr4/blob/master/doc/javascript-target.md)
- [TypeScript](https://github.com/antlr/antlr4/blob/master/doc/typescript-target.md)
- [Go](https://github.com/antlr/antlr4/blob/master/doc/go-target.md)
- [C++](https://github.com/antlr/antlr4/blob/master/doc/cpp-target.md)
- [Swift](https://github.com/antlr/antlr4/blob/master/doc/swift-target.md)
- [PHP](https://github.com/antlr/antlr4/blob/master/doc/php-target.md)
- [DART](https://github.com/antlr/antlr4/blob/master/doc/dart-target.md)

for languages not listed above, there might be an inofficial Antlr-target? Otherwise, you may try to 
[write an Antlr target for you favourite programming language yourself?](https://github.com/antlr/antlr4/blob/master/doc/creating-a-language-target.md).



## Reading your language file

The basic set-up for parsing a file using Antlr is basically the same in all languages:

1. Make sure that the runtime library and the generated lexer and parser files are linked/available
2. Create a character stream or file stream for the input source 
3. Create a lexer and pass it the character stream object
5. Create a CommonTokenStream and pass the lexer object to it 
5. Create a parser and pass the token stream to it 
7. Call the top-level rule on the parser to obtain the parse tree object
7. Run your visitor or listener over the parse tree

The following shows how to run a visitor over a parsed file in Python (requires downlading the respective [PyPI package](https://pypi.org/project/antlr4-python3-runtime/) first!):

```python
import sys 
# 1. import runtime lib and generated files (assuming X is the name of the grammar)
from antlr4 import *
from XLexer import XLexer
from XParser import XParser

class MyVisitor(XBaseVisitor):

    def visit_xyz(self, ctx):
        pass 

    # ... more visitor methods

def main(argv):
    # 2. open input stream
    input_stream = FileStream(argv[1])
    # 3. create lexer object
    lexer = ExprLexer(input_stream)
    # 4. create token stream object
    stream = CommonTokenStream(lexer)
    # 5. create parser objectt
    parser = ExprParser(stream)
    # 6. create parse tree by calling the "top-level rule"
    tree = parser.start_()

    # 7. run the visitor
    vizz = MyVisitor()
    vizz.visit(tree)

if __name__ == '__main__':
    main(sys.argv)
```

## Visiting expression branches

When dealing with expressions, you will have to write all alternatives in the same rule as
we have learned last week since Antlr can only resolve direct left-recursion.
In general, this makes it more cumbersome to distinguish between the different choice
branches in the visitor implementation later.
However, you can use _tags_ to trigger generation of specific visitor methods:

**Before**:
```
expr : expr OP_A expr
    | ...
    | expr OP_N expr 
    ;
```
will generate a single:
```
visit_expr(ctx)
```

whereas **after**:
```
expr : expr OP_A expr # a
    | ...
    | expr OP_N expr  # n
    ;
```

will generate:
```
visit_a(ctx)
...
visit_n(ctx)
```
